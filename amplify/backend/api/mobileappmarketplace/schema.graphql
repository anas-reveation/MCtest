# This "input" configures a global authorization rule to enable public access to
# all models in this schema. Learn more about authorization rules here: https://docs.amplify.aws/cli/graphql/authorization-rules
# input AMPLIFY {
#   globalAuthRule: AuthRule = { allow: public }
# } # FOR TESTING ONLY!

type User
  @model
  @auth(
    rules: [
      { allow: public, operations: [read] }
      { allow: private, operations: [create, read, update] }
      { allow: groups, groups: ["admins"], operations: [create, read, update, delete] }
    ]
  ) {
  id: ID!
  first_name: String!
  last_name: String!
  email: String!
  user_agreement: Boolean @default(value: "true")
  stripe_seller_id: String @default(value: "")
  created_tests: [TestManager] @hasMany(indexName: "byUser", fields: ["id"])
  purchased_tests: [PurchasedTest] @hasMany(indexName: "byUser", fields: ["id"])
  attempted_tests: [AttemptedTest] @hasMany(indexName: "byUser", fields: ["id"])
}

type TestManager
  @model
  @auth(
    rules: [
      { allow: public, operations: [read] }
      { allow: private, operations: [create, read] }
      { allow: groups, groups: ["admins"], operations: [create, read, update, delete] }
    ]
  ) {
  id: ID!
  user_id: ID! @index(name: "byUser")
  created_by: User @hasOne(fields: ["user_id"])
  category_id: ID!
  sub_category_id: ID!
  category: Category @hasOne(fields: ["category_id"])
  title: String!
  description: String!
  reject_description: String
  credit: String
  price: Int!
  status: TestManagerStatus
    @default(value: "IN_PROGRESS")
    @index(name: "testsByStatus", queryField: "listTestsByStatus", sortKeyFields: ["createdAt"])
  tags: [String]
  # In minutes
  time_limit: Int!
  questions: [Question] @hasMany(indexName: "byTest", fields: ["id"])
  createdAt: String!
}

type Question
  @model
  @auth(
    rules: [
      { allow: private, operations: [create, read] }
      { allow: groups, groups: ["admins"], operations: [create, read, update, delete] }
      { allow: public, provider: iam, operations: [read] }
      { allow: public, operations: [read] }
    ]
  ) {
  id: ID!
  marks: Int!
  test_id: ID! @index(name: "byTest")
  test: TestManager @hasOne(fields: ["test_id"])
  question: String!
  answer: String!
  explainantion: String!
  options: AWSJSON!
}

type Category
  @model
  @auth(
    rules: [
      { allow: public, operations: [read] }
      { allow: private, operations: [read] }
      { allow: groups, groups: ["admins"], operations: [create, read, update, delete] }
    ]
  ) {
  id: ID!
  name: String!
  image: String
  sub_category: [SubCategory] @hasMany(indexName: "byCategory", fields: ["id"])
}

type SubCategory
  @model
  @auth(
    rules: [
      { allow: public, operations: [read] }
      { allow: private, operations: [read] }
      { allow: groups, groups: ["admins"], operations: [create, read, update, delete] }
    ]
  ) {
  id: ID!
  name: String!
  category_id: ID! @index(name: "byCategory")
  image: String
  category: Category @hasOne(fields: ["category_id"])
}

type PurchasedTest
  @model
  @auth(
    rules: [
      { allow: private, operations: [create, read] }
      { allow: groups, groups: ["admins"], operations: [create, read, update, delete] }
      { allow: public, operations: [create] }
    ]
  ) {
  id: ID!
  user_id: ID! @index(name: "byUser")
  test_id: ID!
  purchased_by: User @hasOne(fields: ["user_id"])
  test: TestManager @hasOne(fields: ["test_id"])
}

type AttemptedTest
  @model
  @auth(
    rules: [
      { allow: private, operations: [create, read, update] }
      { allow: groups, groups: ["admins"], operations: [create, read, update, delete] }
    ]
  ) {
  id: ID!
  user_id: ID! @index(name: "byUser")
  attempted_by: User @hasOne(fields: ["user_id"])
  test_id: ID!
  test: TestManager @hasOne(fields: ["test_id"])
  status: AttemptStatus!
  # In minutes
  remaining_time: Float
  result: [Result] @hasMany(indexName: "byAttemptedTest", fields: ["id"])
}

type Result
  @model
  @auth(
    rules: [
      { allow: private, operations: [create, read] }
      { allow: groups, groups: ["admins"], operations: [create, read, update, delete] }
      { allow: public, provider: iam, operations: [read, update] }
      { allow: public, operations: [read, update] }
    ]
  ) {
  id: ID!
  attempted_id: ID! @index(name: "byAttemptedTest")
  question_id: ID!
  question: Question @hasOne(fields: ["question_id"])
  user_input: String!
  result_status: Boolean
}

type Promotion
  @model
  @auth(
    rules: [
      { allow: private, operations: [create, read, update] }
      { allow: public, operations: [read] }
    ]
  ) {
  id: ID!
  promotion_code: String!
  discount_percentage: Float!
  expiry_date: AWSDateTime
}

enum AttemptStatus {
  ABORTED
  COMPLETED
  IN_PROGRESS
}

enum TestManagerStatus {
  APPROVED
  IN_PROGRESS
  REJECTED
}

type Query {
  onboardingStripe: String @function(name: "onboardingStripe-${env}")
  getBalance(seller_id: String!): String @function(name: "getBalance-${env}")
  redirectPayoutDashboard(seller_id: String!): String
    @function(name: "redirectPayoutDashboard-${env}")
  getStripeIdStatus(seller_id: String!): String @function(name: "getStripeIdStatus-${env}")
  checkPromoCode(promocode: String!): String @function(name: "checkPromoCode-${env}")
}

type Mutation {
  addResultStatus(result_id: ID!): String @function(name: "checkAnswer-${env}")
  checkoutStripeUrl(
    test_id: ID!
    token: String!
    success_redirect_url: String!
    cancel_redirect_url: String!
    promocode: String
  ): String @function(name: "stripeCheckout-${env}")
}
     